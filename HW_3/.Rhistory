median(M_i)
m_j
j_membership
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:30){
#get top ith visiting probability
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <-comm_struct$membership[as.numeric(index_jth)]
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
#print("v_j and m_j")
#print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
for (j in 1:30){
#get top ith visiting probability
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <-comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
#print("v_j and m_j")
#print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
m_j = rep(0,length(comm_struct)) #n dimensional vector wiht only one element being 1
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:30){
#get top ith visiting probability
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <-comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
#print("v_j and m_j")
#print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
source('~/Documents/EE232E/HW_3/HW_3.R', echo=TRUE)
g_6 <- gcc_ud2
comm_struct <- gcc_ud2_comm_FG
maxexample <- 4
example_count <- 0
while(example_count<maxexample){
# Random Walk and Teleport Params
currStep <- 0
maxSteps <- 20 # 1000000
damping_factor <- 85 # in %
# Initialize path.
path = c()
#choose random start node i
startNode<- sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
path <- c(path,startNode)
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,currentNode)
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(currentNode,nodeNeighbors[k]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
#sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
}
path = c(path,as.numeric(attributes(nextNode)$name))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
# Extract table of node Instances
q <- table(path)
# Calculate probability of being at each node
pr <- q/currStep
#Visiting Probability of all nodes in the network
visiting_prob = pr
#sort visiting probability
sorted_visiting_prob <- sort(visiting_prob,decreasing = TRUE, index.return=TRUE)
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:30){
#get top ith visiting probability
m_j = rep(0,length(comm_struct))  # n dimensional vector wiht only one element being 1
# denotes the community that v_j belongs to
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <-comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
#print("v_j and m_j")
#print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
print("startnode is")
print(startNode)
print("M_i")
print(M_i)
#find out whether M_i includes multiple values greater than the threshold
multiple_comm <- 0
for(k in 1:length(M_i)){
if(M_i[k]>0.5){
multiple_comm <- multiple_comm +1
}
}
#if there are multiple values passing the threshold from prvious for loop, add count to example_count
if(multiple_comm >1){
example_count <- example_count + 1
print("startNode with multiple communities")
print(startNode)
}
}
#PLEASE CHECK: Visualize the result
#startNode should be the same as the startNode from above to compare the results
#startNode <-1090
#Initialize subgraph's verticies
sub_v <- c()
#add startNode to the sub-graph's verticies array
sub_v <- c(sub_v,startNode)
#Get neighbors of the startNode
nodesNeighbors_start <- neighbors(g_6,startNode)
print(nodesNeighbors_start)
#for each neighbor of the startNode, add its neighbors to sub_v array
for (r in 1:length(nodesNeighbors_start)){
sub_v <- c(sub_v,neighbors(g_6,nodesNeighbors_start[r]))
}
#remove the duplicats in sub_v array
unique_sub_v <- unique(sub_v)
#create subgraph with startNode, its neighbors, and their neighbors
sub_g_6 <- induced_subgraph(g_6, unique_sub_v)
plot(sub_g_6,  layout=layout_with_fr, vertex.size = 10, vertex.label.dist = 1,edge.arrow.size=0.5)
#sanity check for numNeighbors == 1
g_6 <- gcc_ud2
comm_struct <- gcc_ud2_comm_FG
count <- 0
currentNode <- 1
while(count <1){
nodeNeighbors <- neighbors(g_6,currentNode)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
print("currentNode")
print(currentNode)
print(nodeNeighbors)
print(numNeighbors)
count <-1
}else{
print("no")
print(currentNode)
currentNode <- currentNode +1
}
}
M_j
M_i
m_j
v_j
sorted_visiting_prob
v_j <- sorted_visiting_prob[1]
v_j
sorted_visiting_prob
sorted_visiting_prob[1]/2
attributes(v_j)$name
length(sorted_visiting_prob)
sum(sorted_visiting_prob)
sum(visiting_prob)
source('~/Documents/EE232E/HW_3/HW_3.R', echo=TRUE)
sum(visiting_prob)
sum(q/(currStep+1))
length(path)
length(currStep)
currStep
v_k
v_j
sorted_visiting_prob[30]
length(sorted_visiting_prob)
source('~/Documents/EE232E/HW_3/HW_3.R', echo=TRUE)
M_i
sum(sorted_visiting_prob)
visiting_prob
startNode
path
q
as.numeric(attributes(nextNode)$name
path
length(path)
numStepsSeg
currStep
currStep/maxSteps
source('~/Documents/EE232E/HW_3/HW_3.R', echo=TRUE)
currStep
M_j
M_i
v_j
sorted_visiting_prob
visiting_prob
path
startNode
length(path)
while(example_count<maxexample){
# Random Walk and Teleport Params
currStep <- 0
maxSteps <- 35 # must be at least 31
damping_factor <- 85 # in %
# Initialize path.
path = c()
#choose random start node i
startNode<- sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
path <- c(path,startNode)
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
print(numStepsSeg)
if ((currStep + numStepsSeg) > maxSteps) {
numStepsSeg = maxSteps - currStep
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,currentNode)
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(currentNode,nodeNeighbors[k]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
# sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
}
path = c(path,as.numeric(attributes(nextNode)$name))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
currStep
path = c()
startNode<- sample(V(g_6),1)
length(path)
startNode
path = c(path, startNode)
path
length(path)
path = c()
startNode<- sample(V(g_6),1)
path <- c(path,startNode)
oath
path
startNode
path = c()
#choose random start node i
startNode<- sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
path <- c(path,startNode)
path
length(path)
path = c()
path <- c(path, 1)
path
sample(V(g_6),1)
path = c()
#choose random start node i
startNode<- sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
path <- c(path,as.numeric(attributes(startNode)$name))
path
length(path)
maxexample <- 4
example_count <- 0
while(example_count<maxexample){
# Random Walk and Teleport Params
currStep <- 0
maxSteps <- 35 # must be at least 31
damping_factor <- 85 # in %
# Initialize path.
path = c()
#choose random start node i
startNode<- sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
path <- c(path,as.numeric(attributes(startNode)$name))
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
print(numStepsSeg)
if ((currStep + numStepsSeg) > maxSteps) {
numStepsSeg = maxSteps - currStep
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,currentNode)
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(currentNode,nodeNeighbors[k]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
# sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
}
path = c(path,as.numeric(attributes(nextNode)$name))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
# Extract table of node Instances
q <- table(path)
# Calculate probability of being at each node, including the starting node due to teleportation
pr <- q/length(path)
#Visiting Probability of all nodes in the network
visiting_prob = pr
#sort visiting probability
sorted_visiting_prob <- sort(visiting_prob,decreasing = TRUE, index.return=TRUE)
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:30){
#get top ith visiting probability
m_j = rep(0,length(comm_struct))  # n dimensional vector wiht only one element being 1
# denotes the community that v_j belongs to
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <- comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
#print("v_j and m_j")
#print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
print("startnode is")
print(startNode)
print("M_i")
print(M_i)
#find out whether M_i includes multiple values greater than the threshold
numComm <- 0
for(k in 1:length(M_i)){
if(M_i[k]>mean(M_i)){
numComm <- numComm +1
}
}
#if there are multiple values passing the threshold from prvious for loop, add count to example_count
if(numComm >1){
example_count <- example_count + 1
print("startNode with multiple communities")
print(startNode)
}
}
length(V(g))
length(E(g))
length(V(gcc))
length(E(gcc))
is.connected(G)
is.connected(g)
plot(gcc_dg_out_hist$count, log="y", type='h', lwd=10, lend=2, main = "Outgoing Degree Distribution", xlab = "Degree", ylab = "Number of Nodes")
points(points(seq(1,10,1), -3*(seq(1,10,1)), col=2, pch=2)
)
plot(degree)
plot(gcc_dg_out)
points(points(seq(1,10,1), -3*(seq(1,10,1)), col=2, pch=2)
)
-3*(seq(1,10,1)
points(points(seq(1,10,1), -3*log(seq(1,10,1)), col=2, pch=2)
)
log(seq(1,10,1))
-3*log(seq(1,10,1))
points(points(seq(1,10,1), -3*log(seq(1,10,1)), col=2, pch=2)
)
plot(log(gcc_dg_out))
plot(log(gcc_dg_out_hist))
plot(log((gcc_dg_out_hist)$count))
points(points(seq(1,10,1), -3*log(seq(1,10,1)), col=2, pch=2)
)
points(points(seq(1,10,1), 3*log(seq(1,10,1)), col=2, pch=2)
)
points(points(seq(1,10,1), 3*log(seq(1,10,1))+8, col=2, pch=2)
)
points(points(seq(1,10,1), -3*log(seq(1,10,1))+8, col=2, pch=2)
)
plot(log((gcc_dg_out_hist)$count))
points(points(seq(1,10,1), -2*log(seq(1,10,1))+8, col=2, pch=2)
)
points(points(seq(1,10,1), -4*log(seq(1,10,1))+8, col=2, pch=2)
)
points(points(seq(1,10,1), log(seq(1,10,1))^-3, col=2, pch=2)
)
plot(gcc_dg_out_hist$count, log="y", type='h', lwd=10, lend=2, main = "Outgoing Degree Distribution", xlab = "Degree", ylab = "Number of Nodes")
points(points(seq(1,10,1), log(seq(1,10,1))^-3, col=2, pch=2)
+ )
points(points(seq(1,10,1), log(seq(1,10,1))^-3, col=2, pch=2))
points(points(seq(1,10,1), length(V(gcc))*log(seq(1,10,1))^-3, col=2, pch=2))
plot(gcc_dg_out_hist$count, log="y", type='h', lwd=10, lend=2, main = "Outgoing Degree Distribution", xlab = "Degree", ylab = "Number of Nodes")
points(points(seq(1,10,1), length(V(gcc))*log(seq(1,10,1))^-3, col=2, pch=2))
length(V(gcc))*log(seq(1,10,1))^-3
log(seq(1,10,1))^-3
degreeHist <- hist(gcc_dg_out, plot = "FALSE")$density
x_plot <- hist(gcc_dg_out, plot = "FALSE")$mids
plot(x_plot, degreeHist)
plot(gcc_dg_out_hist$count, log="xy", type='h', lwd=10, lend=2, main = "Outgoing Degree Distribution", xlab = "Degree", ylab = "Number of Nodes")
plot(gcc_dg_in_hist$count, log="xy", type='h', lwd=10, lend=2, main = "Outgoing Degree Distribution", xlab = "Degree", ylab = "Number of Nodes")
plot(gcc_dg_in_hist$count, log="xy", type='h', lwd=10, lend=2, main = "Incoming Degree Distribution", xlab = "Degree", ylab = "Number of Nodes")
gcc_ud2_comm_LP <- label.propagation.community(gcc_ud1)
gcc_ud1_comm_FG <- fastgreedy.community(gcc_ud1)
gcc_ud1_comm_LP <- label.propagation.community(gcc_ud1)
