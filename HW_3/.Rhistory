# Initialize path.
path = c()
#choose random start node i
startNode<- 10177#sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
#path <- c(path,as.numeric(attributes(startNode)$name))
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
print(numStepsSeg)
if ((currStep + numStepsSeg) > maxSteps) {
numStepsSeg = maxSteps - currStep
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,V(g_6)[currentNode])
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(V(g_6)[currentNode],V(g_6)[nodeNeighbors[k]]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
# print("edge_weight_prob")
# print(edge_weight_prob)
# sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
print("nextNode")
print(nextNode)
}
path = c(path,as.numeric(V(g_6)[nextNode]))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
# Extract table of node Instances
q <- table(path)
# Calculate probability of being at each node, including the starting node due to teleportation
pr <- q/length(path)
#Visiting Probability of all nodes in the network
visiting_prob = pr
#sort visiting probability
sorted_visiting_prob <- sort(visiting_prob,decreasing = TRUE, index.return=TRUE)
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
if(option == 1){
print("option1")
v_j_length <- as.numeric(length(pr))
}else{
v_j_length <- as.numeric(30)
}
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:v_j_length){
#get top ith visiting probability
m_j = rep(0,length(comm_struct))  # n dimensional vector wiht only one element being 1
# denotes the community that v_j belongs to
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <- comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
print("v_j and m_j")
print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
print("M_i")
print(M_i)
#find out whether M_i includes multiple values greater than the threshold
numComm <- 0
for(k in 1:length(M_i)){
if(M_i[k]>0.1){
numComm <- numComm + 1
}
}
#if there are multiple values passing the threshold from prvious for loop, add count to example_count
if(numComm >1){
print("startNode with multiple communities")
print("F: startnode is")
print(startNode)
print("M_i")
print(M_i)
example_count <- example_count + 1
}
}
#Problem 6
#choose which optino to try Problem 6
option <- 1
if(option == 2){
g_6 <- gcc_ud2
comm_struct <- gcc_ud2_comm_FG
}else {
print("option1")
g_6 <- gcc_ud1
comm_struct <- gcc_ud1_comm
}
maxexample <- 4
example_count <- 0
while(example_count<maxexample){
# Random Walk and Teleport Params
currStep <- 0
maxSteps <- 35 # must be at least 31
damping_factor <- 85 # in %
# Initialize path.
path = c()
#choose random start node i
startNode<- 10401#sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
#path <- c(path,as.numeric(attributes(startNode)$name))
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
print(numStepsSeg)
if ((currStep + numStepsSeg) > maxSteps) {
numStepsSeg = maxSteps - currStep
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,V(g_6)[currentNode])
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(V(g_6)[currentNode],V(g_6)[nodeNeighbors[k]]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
# print("edge_weight_prob")
# print(edge_weight_prob)
# sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
print("nextNode")
print(nextNode)
}
path = c(path,as.numeric(V(g_6)[nextNode]))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
# Extract table of node Instances
q <- table(path)
# Calculate probability of being at each node, including the starting node due to teleportation
pr <- q/length(path)
#Visiting Probability of all nodes in the network
visiting_prob = pr
#sort visiting probability
sorted_visiting_prob <- sort(visiting_prob,decreasing = TRUE, index.return=TRUE)
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
if(option == 1){
print("option1")
v_j_length <- as.numeric(length(pr))
}else{
v_j_length <- as.numeric(30)
}
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:v_j_length){
#get top ith visiting probability
m_j = rep(0,length(comm_struct))  # n dimensional vector wiht only one element being 1
# denotes the community that v_j belongs to
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <- comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
print("v_j and m_j")
print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
print("M_i")
print(M_i)
#find out whether M_i includes multiple values greater than the threshold
numComm <- 0
for(k in 1:length(M_i)){
if(M_i[k]>0.1){
numComm <- numComm + 1
}
}
#if there are multiple values passing the threshold from prvious for loop, add count to example_count
if(numComm >1){
print("startNode with multiple communities")
print("F: startnode is")
print(startNode)
print("M_i")
print(M_i)
example_count <- example_count + 1
}
}
#Problem 6
#choose which optino to try Problem 6
option <- 1
if(option == 2){
g_6 <- gcc_ud2
comm_struct <- gcc_ud2_comm_FG
}else {
print("option1")
g_6 <- gcc_ud1
comm_struct <- gcc_ud1_comm
}
maxexample <- 4
example_count <- 0
while(example_count<maxexample){
# Random Walk and Teleport Params
currStep <- 0
maxSteps <- 35 # must be at least 31
damping_factor <- 85 # in %
# Initialize path.
path = c()
#choose random start node i
startNode<- 10349#sample(V(g_6),1)
#PLEASE CHECK: Do we add startNode to the path?
#path <- c(path,as.numeric(attributes(startNode)$name))
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
print(numStepsSeg)
if ((currStep + numStepsSeg) > maxSteps) {
numStepsSeg = maxSteps - currStep
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,V(g_6)[currentNode])
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(V(g_6)[currentNode],V(g_6)[nodeNeighbors[k]]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
# print("edge_weight_prob")
# print(edge_weight_prob)
# sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
print("nextNode")
print(nextNode)
}
path = c(path,as.numeric(V(g_6)[nextNode]))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
# Extract table of node Instances
q <- table(path)
# Calculate probability of being at each node, including the starting node due to teleportation
pr <- q/length(path)
#Visiting Probability of all nodes in the network
visiting_prob = pr
#sort visiting probability
sorted_visiting_prob <- sort(visiting_prob,decreasing = TRUE, index.return=TRUE)
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
if(option == 1){
print("option1")
v_j_length <- as.numeric(length(pr))
}else{
v_j_length <- as.numeric(30)
}
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:v_j_length){
#get top ith visiting probability
m_j = rep(0,length(comm_struct))  # n dimensional vector wiht only one element being 1
# denotes the community that v_j belongs to
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <- comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
print("v_j and m_j")
print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
print("M_i")
print(M_i)
#find out whether M_i includes multiple values greater than the threshold
numComm <- 0
for(k in 1:length(M_i)){
if(M_i[k]>0.1){
numComm <- numComm + 1
}
}
#if there are multiple values passing the threshold from prvious for loop, add count to example_count
if(numComm >1){
print("startNode with multiple communities")
print("F: startnode is")
print(startNode)
print("M_i")
print(M_i)
example_count <- example_count + 1
}
}
print(V(g)[10177])
print(V(g)[10401])
print(V(g)[10349])
#choose which optino to try Problem 6
option <- 2
if(option == 2){
g_6 <- gcc_ud2
comm_struct <- gcc_ud2_comm_FG
}else {
print("option1")
g_6 <- gcc_ud1
comm_struct <- gcc_ud1_comm
}
maxexample <- 4
example_count <- 0
while(example_count<maxexample){
# Random Walk and Teleport Params
currStep <- 0
maxSteps <- 35 # must be at least 31
damping_factor <- 85 # in %
# Initialize path.
path = c()
#choose random start node i
startNode<- sample(length(V(g_6)),1)
#PLEASE CHECK: Do we add startNode to the path?
#path <- c(path,as.numeric(attributes(startNode)$name))
# Run until you get enough steps in the path
while (currStep < maxSteps)
{
# Calculate length of segment before teleportation occurs
numStepsSeg <- 1 # Initialize number of steps before teleportation occurs
# Calculate whether teleportation occurs
smp <- sample(1:100,1)
while(smp<=damping_factor)
{
# If no teleportation, continue incrementing numStepsSeg
numStepsSeg <- numStepsSeg + 1
smp <- sample(1:100,1)
}
print(numStepsSeg)
if ((currStep + numStepsSeg) > maxSteps) {
numStepsSeg = maxSteps - currStep
}
currentNode<- startNode
for(t in 1:numStepsSeg){
nodeNeighbors <- neighbors(g_6,V(g_6)[currentNode])
#print("neighborNodes")
#print(nodeNeighbors)
numNeighbors <- length(nodeNeighbors)
if(numNeighbors == 1){
nextNode <- nodeNeighbors
}else{
#calculate edge weight
edge_weight <- rep(0,numNeighbors)
for (k in 1:numNeighbors){
edge_weight[k] <- E(g_6,P=c(V(g_6)[currentNode],V(g_6)[nodeNeighbors[k]]))$weight
}
#calculate probability
edge_weight_prob <-  rep(0,numNeighbors)
sum_weight <- sum(edge_weight)
for (l in 1:numNeighbors){
edge_weight_prob[l] <- (1-edge_weight[l]/sum_weight)/(numNeighbors-1)
}
# print("edge_weight_prob")
# print(edge_weight_prob)
# sample nextNode
nextNode <-  sample(nodeNeighbors, 1, replace = TRUE, prob = edge_weight_prob)
# Append segment to path
print("nextNode")
print(nextNode)
}
path = c(path,as.numeric(V(g_6)[nextNode]))
currentNode <- nextNode
}
# Increment number of steps
currStep <- currStep + numStepsSeg
print(currStep/maxSteps)
}
# Extract table of node Instances
q <- table(path)
# Calculate probability of being at each node, including the starting node due to teleportation
pr <- q/length(path)
#Visiting Probability of all nodes in the network
visiting_prob = pr
#sort visiting probability
sorted_visiting_prob <- sort(visiting_prob,decreasing = TRUE, index.return=TRUE)
#initialize M_i and m_j
M_i = rep(0,length(comm_struct))
if(option == 1){
print("option1")
v_j_length <- as.numeric(length(pr))
}else{
v_j_length <- as.numeric(30)
}
#calculate M_i with nodes j of top 30 visiting probability
for (j in 1:v_j_length){
#get top ith visiting probability
m_j = rep(0,length(comm_struct))  # n dimensional vector wiht only one element being 1
# denotes the community that v_j belongs to
v_j <- sorted_visiting_prob[j]
#get top ith visiting probability's node index
index_jth <- attributes(v_j)$name
#get top ith node index's membership
j_membership <- comm_struct$membership[as.numeric(index_jth)]
print(j_membership)
#build m_j (all 0s and 1 at j_membership)
m_j[j_membership]<-1
print("v_j and m_j")
print(index_jth)
print(m_j)
#calculate M_i
M_i <- M_i + (v_j*m_j)
#print("M_i")
#print(M_i)
}
print("M_i")
print(M_i)
#find out whether M_i includes multiple values greater than the threshold
numComm <- 0
for(k in 1:length(M_i)){
if(M_i[k]>0.1){
numComm <- numComm + 1
}
}
#if there are multiple values passing the threshold from prvious for loop, add count to example_count
if(numComm >1){
print("startNode with multiple communities")
print("F: startnode is")
print(V(g_6)[startNode])
print("M_i")
print(M_i)
example_count <- example_count + 1
}
}
